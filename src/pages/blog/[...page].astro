---
// src/pages/blog/[...page].astro
import { getCollection, type CollectionEntry } from 'astro:content';
import BaseLayout from '../../layouts/BaseLayout.astro'; 
import BlogCard from '../../components/BlogCard.astro';   
import Pagination from '../../components/Pagination.astro'; 
import type { Page, PaginateFunction, GetStaticPathsResult } from 'astro'; // Added GetStaticPathsResult for typing 'p'

// Define the props for each generated page route by paginate
interface PaginatedBlogRouteProps {
  page: Page<CollectionEntry<'blog'>>;
}
// Define the structure of an individual item in the array returned by paginate
type PaginateResultItem = {
  params: { page: string | undefined }; // Or Record<string, string | undefined> if page param name differs
  props: PaginatedBlogRouteProps;
};


export async function getStaticPaths({ paginate }: { paginate: PaginateFunction }) {
  console.log("[blog/[...page].astro] getStaticPaths: Fetching blog collection...");
  const allBlogPosts = await getCollection('blog', (entry: CollectionEntry<'blog'>) => {
    return entry.data.isDraft !== true; 
  });
  console.log(`[blog/[...page].astro] getStaticPaths: Found ${allBlogPosts.length} raw entries from getCollection (after draft filter).`);

  const sortedPosts = allBlogPosts.sort((a: CollectionEntry<'blog'>, b: CollectionEntry<'blog'>) => {
    const dateA = a.data.publishDate ? new Date(a.data.publishDate).valueOf() : 0;
    const dateB = b.data.publishDate ? new Date(b.data.publishDate).valueOf() : 0;
    return dateB - dateA;
  });
  
  console.log(`[blog/[...page].astro] getStaticPaths: Found ${sortedPosts.length} non-draft blog posts to paginate.`);
  if (sortedPosts.length === 0) {
    console.warn("[blog/[...page].astro] getStaticPaths: No publishable blog posts found. Paginate will be called with an empty array. This might lead to an empty blog index page.");
  }
  
  const paginationResult = paginate(sortedPosts, { pageSize: 6 }); 
  
  console.log("[blog/[...page].astro] getStaticPaths: Pagination result (paths to be generated):", JSON.stringify(
    // MODIFIED: Explicitly type 'p' here
    paginationResult.map((p: PaginateResultItem) => ({ 
        params: p.params, 
        propsKeys: p.props ? Object.keys(p.props) : [] // Guard against p.props being null/undefined
    })), 
    null, 
    2
  ));
  return paginationResult;
}

// Props for the page component itself
interface Props {
  page: Page<CollectionEntry<'blog'>>; 
}
const { page } = Astro.props as Props; 

if (!page) {
  console.error(`[blog/[...page].astro] CRITICAL: 'page' prop is undefined for Astro.props:`, JSON.stringify(Astro.props));
}

const pageTitle = "Our Blog & Knowledge Base";
const pageDescription = "Explore articles, insights, and updates from Onco Solutions on lighting, automation, and more.";

const currentPage = page?.currentPage ?? 1;
const postsToDisplay = page?.data ?? [];
const lastPage = page?.lastPage ?? 1; 

const currentPageTitle = page && page.currentPage > 1 ? `${pageTitle} - Page ${page.currentPage}` : pageTitle;
---
<BaseLayout title={currentPageTitle} description={pageDescription}>
  <div class="blog-index-container container">
    <header class="blog-header">
      <h1 class="page-main-title"><span>{pageTitle}</span></h1>
      {currentPage === 1 && (
        <p class="blog-intro">
          Discover insights, tips, and updates on smart lighting, automation, 
          and innovative solutions from the Onco Solutions team.
        </p>
      )}
    </header>

    {postsToDisplay.length > 0 ? (
      <div class="blog-posts-grid">
        {postsToDisplay.map((post: CollectionEntry<'blog'>) => ( // This was already correctly typed
          <BlogCard post={post} />
        ))}
      </div>
    ) : (
      <p class="no-posts-message">No blog posts found. Check back soon!</p>
    )}

    {page && lastPage > 1 && <Pagination page={page} base="/blog" />}
  </div>
</BaseLayout>

<style>
  /* Styles from previous version are assumed here */
  .blog-index-container {
    padding-top: 2rem;
    padding-bottom: 2rem;
    box-sizing: border-box; 
  }

  .blog-header {
    text-align: center;
    margin-bottom: 3rem;
  }

  .page-main-title {
    margin-bottom: 1rem;
    color: var(--dark-blue);
    font-size: 2.5rem;
    font-weight: 700;
    position: relative;
    display: block; 
  }
  .page-main-title span {
    display: inline-block; 
    position: relative;
    padding-bottom: 0.5rem;
  }
  .page-main-title span::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 60px;
    height: 4px;
    background-color: var(--primary-color);
  }

  .blog-intro {
    font-size: 1.1rem;
    color: var(--text-color);
    max-width: 700px;
    margin: 0 auto 1.5rem auto;
    line-height: 1.6;
  }

  .blog-posts-grid {
    display: grid;
    grid-template-columns: 1fr; 
    gap: 2rem; 
  }

  @media (min-width: 640px) { 
    .blog-posts-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }
  @media (min-width: 992px) { 
    .blog-posts-grid {
      grid-template-columns: repeat(3, 1fr); 
    }
  }
  .no-posts-message {
    text-align: center;
    font-size: 1.1rem;
    color: var(--secondary-color);
    padding: 2rem 0;
  }
</style>
